#![allow(dead_code)]

struct Solution;

impl Solution {
    /// 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。
    ///
    /// 提示：
    /// ```
    ///     0 <= n <= 2 * 10^9
    /// ```
    ///
    /// 举个例子： n = 2304 。答案为四个部分之和：
    ///
    /// 1. 所有小于等于2304的正整数中，个位出现1的次数.
    /// 2. 所有小于等于2304的正整数中，十位出现1的次数.
    /// 3. 所有小于等于2304的正整数中，百位出现1的次数.
    /// 4. 所有小于等于2304的正整数中，千位出现1的次数.
    /// 
    /// 这四部分可以只考虑一部分，另外三部分就异曲同工了。用第二部分来举例，也就是计算所有小于等于2304的正整数中，十位出现1的次数：
    ///
    /// 为了帮助理解，我们先想象有一个自行车密码锁（这个比喻来自@ryan0414），一共有四位，每一位可单独滚动。为了计算十位出现1的次数，我们考虑三种情况：
    ///
    /// 1. n中的十位为0. 即 n = 2304。
    /// 
    ///     我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。
    ///
    ///     不难发现，我们能滚出的最大数是：2219,
    ///
    ///     我们能滚出的最小数是：0010。
    ///
    ///     那么0010到2219之间有多少种十位为1的密码呢？我们去掉十位，得到000和229。一共就是229-000+1 = 230种。即n千位和百位构成的数。
    ///
    /// 2. n中的十位为1. 即 n = 2314。
    /// 
    ///     我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。
    ///
    ///     不难发现，我们能滚出的最大数是：2314,
    ///
    ///     我们能滚出的最小数是：0010。
    ///
    ///     那么0010到2314之间有多少种十位为1的密码呢？我们去掉十位，得到000和234，一共就是23*10+4+1 = 235种。即n千位和百位构成的数*10 + n个位的数字+1.
    ///
    /// 3. n中的十位为2~9中任意数字. 即 n = 2324（只是一个例子，n = 2394是一样的）。
    /// 
    ///     我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。
    ///
    ///     不难发现，我们能滚出的最大数是：2319,
    ///
    ///     我们能滚出的最小数是：0010。
    ///
    ///     那么0010到2319之间有多少种十位为1的密码呢？我们去掉十位，得到000和239，一共就是（23+1）*10 = 240种。即(n万位和千位构成的数*+1)*10.
    ///
    /// 如果我们定义十位左边的数为高位，2304的高位为23，十位右边的数为低位，2304的低位为4，那么以上规律就可以写成高位和低位的规律。我们分别对2304的每一位做一次分析，并将四部分结果相加就得到了答案。
    fn count_digit_one(n: i32) -> i32 {
        let (mut digit, mut res) = (1, 0);
        let (mut high, mut cur, mut low) = (n / 10, n % 10, 0);

        while high != 0 || cur != 0 {
            if cur == 0 {
                res += high * digit;
            } else if cur == 1 {
                res += high * digit + low + 1;
            } else {
                res += (high + 1) * digit;
            }
            low += cur * digit;
            cur = high % 10;
            high /= 10;
            digit *= 10;
        }

        res
    }
}

pub fn test(n: i32) -> i32 {
    Solution::count_digit_one(n)
}

#[cfg(test)]
mod tests {
  use super::*;
  #[test]
  fn count_digit_one() {
    assert_eq!(6, Solution::count_digit_one(13));
  }
}
